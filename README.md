# JavaConcurrency
Java并发编程学习相关，主要跟着项目驱动学习并发编程

synchronized关键字 表示对某个对象加锁<br>
读写都应该加锁  不然可能会出现脏读  但是会影响性能<br>

一个同步方法可以调用另一个同步方法，<br>
   一个线程已经拥有某个对象的锁，
   <br>再次申请的时候仍然会得到该对象的锁<br>
   也就是说synchronized获得的锁是可重入的<br>
   
   程序在执行的过程中，如果出现异常，默认情况锁会被释放
   所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况
   比如在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时异常情况处理不合适，
   在一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时数据。
   因此要非常小心的处理同步业务逻辑中的异常
   
   volatile 关键字，使一个变量在多个线程间可见
           * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
           * 使用volatile关键字，会让所有线程都会读到变量的修改值
           *
           * 在下面的代码中，running是存在于堆内存的t对象中
           * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去
           * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行
           *
           * 使用volatile，将会强制所有线程都去堆内存中读取running的值
           *
           * 可以阅读这篇文章进行更深入的理解
           * http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
           *
           * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized